<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C4Coffee</title>
    <description>&gt; Engineer. Robots. Coffee.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 17 Dec 2016 18:57:00 -0800</pubDate>
    <lastBuildDate>Sat, 17 Dec 2016 18:57:00 -0800</lastBuildDate>
    <generator>Jekyll v3.3.0</generator>
    
      <item>
        <title>DIY AM Radio Design - Part2: Circuit Implementation</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://c4coffee.ca/2016/10/30/diy-am-radio.html&quot;&gt;Continuing from the previous post&lt;/a&gt;, this post is going to describe the implementation of the actual radio.&lt;/p&gt;

&lt;h2 id=&quot;reference-circuits&quot;&gt;Reference Circuits&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This circuit is an example of a basic crystal radio circuit. &lt;b&gt;L1&lt;/b&gt; and &lt;b&gt;C1&lt;/b&gt; is the tuning circuit that is a band pass filter. The &lt;b&gt;diode&lt;/b&gt; following is the peak detector that allows us to convert the received radio signals to audio.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;final-circuit-design&quot;&gt;Final Circuit Design&lt;/h2&gt;

&lt;p&gt;Our final design (Fig 2.A) included extension capabilities for different audio sources. This is to ensure that the end user is not limited to the rare and uncommon piezoelectric speakers and crystal earphones used in the testing process.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fig 2.A.1 - Final Circuit Including Extensions&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The strategy used for final implementation surrounded picking from a variety of different designs used for each function block (Labeled in Fig.2.A.1) and using the best performing combination. The amplification circuit was developed first as it was hard to test the quality of our tuning circuit without proper amplification of the AF signal produced. After we confirmed that our first amplification stage was sufficient for testing the tuning circuit, we focused on the design of our transformer within the tuning circuit for best RF results.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fig 2.A.2- Main Function Blocks Labeled&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Below (Fig 2.A.2) is our intermediate testing setup for most of the tuning circuit design process. The main improvements made from the first amplification stage was the switch from a crystal earphone to a piezoelectric speakers. We made this change to reduce the discomfort from the fluctuation and noise introduced in the circuit tuning process.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fig 2.A.3 - Intermediate Testing Circuit&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;From the labeled figure below, we can see the main components to the intermediate testing circuit. The peak detector and 2 stage audio amplification circuit was constant through the whole circuit tuning process. The tuning circuit displayed below is the final setup, not the preliminary design. The reason why a second audio amplifier was added was to ensure that there was enough gain for both the crystal earphones and piezoelectric speakers.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fig 2.A.4 - Intermediate Testing Circuit Labeled&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;antenna-design&quot;&gt;Antenna Design&lt;/h2&gt;

&lt;p&gt;The main antenna that was used in the research process was the rooftop antenna provided to us within the labs. This antenna was constructed by simply extending a long 22 AWG wire along the side of the building and across the rooftop.&lt;/p&gt;

&lt;p&gt;Though there were antennas provided in the lab, to address the portability aspects of our radio, we made sure to construct and test our own antennas after we had created our intermediate testing circuit.&lt;/p&gt;

&lt;p&gt;Two test antennas were constructed with 7 loop of 22 gauge conductor wire, with the difference being solid core v. threaded wire core. Performance was tested by comparing the audio output performance with the radio frequency tuned to CBC Radio One (890 AM). The reason CBC was selected for testing was because we were expecting limited results from our own antennas due to the faraday shielding nature of our building. With CBC being the strongest signal that we can receive, we would have a better chance of having observable results.&lt;/p&gt;

&lt;p&gt;The experiment was conducted based off of the hypothesis that the stranded wire would produce better results than the solid core wire due to losses from skin effect. However, the result was that we were unable to hear any signals being picked up using the stranded wire. Due to the qualitative nature of our test, we could not confirm the reason of the poor performance of the threaded wire. A quantitative method was proposed by measuring the magnitude of received signals using the spectrum analyzer to confirm performance. However, due to the short time frame and limits in available apparatus, this experiment was not carried forward. The rest of the experiment was carried forward by using the provided roof antennas and ¼ wavelength antennas.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fig 2.B.1 - Threaded 22AWG Loop Antenna (Left) Solid 22AWG Loop Antenna (Right)&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;rf-amplifier&quot;&gt;RF Amplifier&lt;/h2&gt;

&lt;p&gt;The RF amplifier is the real design challenge in this project. After looking through various designs, I decided that the most efficient design was to use a 2 in 1 tuning circuit + amplifier. Since we were dealing with radio signals, a transformer design with the correct resonance inductance would be the perfect performance enhancer.&lt;/p&gt;

&lt;p&gt;An active RF amplifier was considered in the design process as it was one of two possible amplification stages we could implement in terms of a general radio design. However, through research it was noticed that most AM radios do not implement active RF amplification circuits due to the time and monetary cost trade off to actual performance increase. Therefore we did not carry forward in designing and implementing an RF amplifier.&lt;/p&gt;

&lt;p&gt;It is important to note, that during our conversations with our project advisor, we learned that commonly MOSFETS were used for RF Amplification circuits due to their fast switch speed (In respect to BJTs) for output at linear operation. In comparison, BJTs do not operate as efficiently for RF processes due to power loss in current draw, which can be easily affected by external factors including temperature and large signal fluctuations.
Voltage doublers and clampers were also considered in the design process. However from the peak detector performance, we decided that it was not necessary for good performance.&lt;/p&gt;

&lt;p&gt;Our final decision for addressing RF amplification was to use a step-up transformer. A passive process was selected in hopes that in times where the system lacks power, a minimum signal can be heard with high impedance audio devices. Further, a transformer being magnetically coupled will be able to ensure that only the AC components of our received radio signal is being fed into the rest of our circuit.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fig 2.C.1 - Tuning circuit transformer that acts as amplifier&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The transformer also acts as part of the tuning circuit. The functionality and tuning applications for the toroidal transformer will be discussed below in the tuning circuit section.&lt;/p&gt;

&lt;h2 id=&quot;tuning-circuit&quot;&gt;Tuning Circuit&lt;/h2&gt;

&lt;p&gt;The tuning circuit design is a tank circuit that would act as a band pass filter for the frequencies we wish to receive. Being provided with a 450pF and 900pF variable capacitor, it was decided that the fastest approach to a working tuning circuit would be to build a non variable inductor and have the radio tuned exclusively by the variable capacitors.&lt;/p&gt;

&lt;p&gt;To approach with inductor design, we had to start by figuring out the inductor size we needed for filtering the correct frequencies. The inductor values were calculated by calculating the necessary inductor value from the mid point capacitance on the capacitors (Roughly 225pF and 450pF respectively). The relationship used was:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f  = 12 LC&lt;/script&gt;

&lt;p&gt;Further, we had to decide between the type of inductor core to use in our fabrications processes. Though through research we learned that radio users prefer air coils due to lack of core losses. However, it was also noted during research that by connecting the antenna directly to a ferrite core inductor, we can create what’s known as a loopstick antenna. Loopstick antenna’s though are not very efficient, they are well suited for receiving within the AM frequency bandwidth (500kHz - 1600kHz). Thus our inductor designs through the project surrounded various types of ferrite cores that were available for purchase.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fig 2.D.1 - Different Iterations of Tuning Design&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In Fig 2.D.1 there are three different circuit designs that we put into consideration from the beginning. On the left there is a parallel LC circuit with both a variable capacitor and a variable inductor connected to the antenna. The benefit of this circuit is that it provides us with the ability to not only select channels with the inductor (giving us a higher Q factor) but also allow us to do fine adjustments with the capacitor if needed. Our approach to fabricating the variable inductor was to create a toroidal inductor and had one surface sanded. By moving a conducting brush or wire across the sanded surface, we would be able to adjust the inductance to our needs. This design can be seen in Fig 2.H. However due to the limitations in our crafting skills and ferrite cores to pick from, we were unable to produce a variable inductor with satisfactory results.&lt;/p&gt;

&lt;p&gt;In the middle, there is a parallel LC circuit with a variable capacitor and a set value inductor measured at around 2.5mH. This design was used for a large portion of design in the intermediate circuit during the development of further audio amplification techniques. The toroidal inductor can also be seen in Fig 2.D.2 alongside other inductor types we fabricated for testing.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-8.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fig 2.D.2 - Various Types of Toroidal Ferrite Inductors  (Left) Variable Toroidal Inductor (Right - Top) Toroidal Transformer (Right - Bottom) 2.5mH Toroidal Inductor&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Last, there is the toroidal transformer design that we ended up implementing in our final circuit. The fabrication process was identical to previous toroidal inductors we made with the only difference being that there was an extra secondary winding on the toroid. It was very important to ensure that the two windings were looped in the same direction so the flux would add up properly giving us the best results. The model shown in Fig 2.H is one of the prototypes we used during the testing processes, however it did not give us the best results, so we opted for the transformer seen in Fig 2.F.&lt;/p&gt;

&lt;p&gt;It is important to note that, to ensure there was the least amount of resistance in the circuit as possible, our team opted for thicker wires than the ones the lab provided. (22AWG replaced the 26AWG magnet wire).&lt;/p&gt;

&lt;h2 id=&quot;detector&quot;&gt;Detector&lt;/h2&gt;

&lt;p&gt;Out of the various types of peak detectors, we decided to use a simple diode structure to carry forward the detector task. However other possibilities were considered in the design process and will be discussed below.&lt;/p&gt;

&lt;p&gt;To our understanding, the best performance can be obtained by using a superheterodyne receiver. Below is our theoretical circuit that we would use to carry out the process.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-E1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fig 2.E.1 - Superheterodyne Receiver Radio Circuit with Mixer Demodulation&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-E2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fig 2.E.2 - Superheterodyne Receiver Radio Circuit with Peak Detector&lt;/p&gt;

&lt;p&gt;Due to the lack of time we did not carry forward in prototyping this circuit as it requires us to tap our own transformers specifically for constructing the mixer. Further, the results we were getting from a simple diode peak detector was sufficient in producing clear audio signals. It is important to note that the 1N34 Germanium diode was selected specifically due to the low voltage drop of 0.2V as opposed to 0.7V of a normal rectifier. The resistor and capacitor values were selected so our sampling time frequency is enough to follow the input RF signal.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-E3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fig 2.E.3 - 1N34 Peak Detector&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-E4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fig 2.E.4 - Voltage Drop across detector with 1N34 Germanium diode&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-E5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fig 2.E.5 -Voltage Drop across detector with 1N270 Germanium diode&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-E6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fig 2.E.6 - Voltage Drop across detector with IN4739A zenner diode&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-E7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fig 2.E.7 - Voltage Drop across detector with 1N5711 SCHOTTKY diode&lt;/p&gt;

&lt;p&gt;As you can observe from Fig.2.E.4 and Fig.2.E.5, 1N34 and 1N270 Germanium diode have a low forward bias voltage drop of 0.2V, as opposed to 0.7V of a normal rectifier. In contrast, 1N5711 SCHOTTKY diode and 1N4739 diode have a higher voltage drop of 0.3V. Since the peak value of the peak detector is not totally exact to the true peak value of the input because of the inherent built-in voltage drop, we want a diode that has as lowest voltage drop as possible. We want the capacitor can output a DC voltage equal to the peak value of the detector, and as a consequence, it would make sense to select to use Germanium diode like 1N34 and 1N270 because of its low inherent built-in voltage drop. On the other hand, our crystal radio receiver usually produces around 0.1 volt. The Germanium can start to conduct at very low voltages like 0.1 volt.&lt;/p&gt;

&lt;h2 id=&quot;audio-amplifier&quot;&gt;Audio amplifier&lt;/h2&gt;

&lt;p&gt;As discussed earlier, we have implemented a variety of audio amplifiers for different purposes. In this section, we will provide information about all audio amplifiers we have worked with and their specific applications.&lt;/p&gt;

&lt;p&gt;Below (Fig 2.F.1) is a diagram of our first stage audio amplification circuit. The design consisted of a simple collector feedback biased amplification circuit. The 10uF capacitor was selected as a bypass capacitor to prevent any noise that is present, or generated in the circuit. We will later realize that a capacitor with a higher frequency response was needed. The 1uF capacitors in the circuit act as coupling capacitors to ensure that the only signals carried forward are the AC signals.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-F1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fig 2.F.1 - First Stage Audio Amplification Circuit&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;By plotting the frequency response of the first stage audio amplification circuit shown in Fig 3.F.2 we can observe that the maximum gain is -9.96dB. With the 3-dB frequencies occurring between 3.950kHz and 513kHz.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-F2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fig 2.F.2 - Magnitude Bode Plot of First Stage Audio Amplification&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It can be observed that the max gain covers the higher end of the human hearing spectrum (20-20kHz) but lowers in the 1kHz to 4kHz region which is the region humans are most sensitive in. Putting the simulation data aside, practical use of the circuit was indeed hard operate due to the low gain coming from the crystal earphones.  Therefore we decided that another amplification stage was needed.&lt;/p&gt;

&lt;p&gt;The second amplification was a simple cascade of the same transistor setup with a potentiometer in place of the collector resistor. This will allow us to adjust the amount of gain by  changing the bias voltage at the collector terminal. The implemented circuit can be seen below (Fig 2.F.3):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-F3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fig 2.F.3 - Circuit with Second Amplification Stage&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The frequency response of the circuit was evaluated again after the introduction of the second amplification circuit.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-F4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fig 2.F.4 - Magnitude Bode Plot of Circuit with Second Amplification Stage&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;From the bode plot it can be observed that the frequency was not adjusted much compared to the first amplification circuit. Though we could have adjusted the coupling capacitor values to shift the 3dB point towards the low frequency end to better cover the human hearing range, the practical results from using the radio showed that the frequency response was enough.&lt;br /&gt;
It should also be noted that the max gain is at -4.720dB, which is 5dB higher than the first stage amplification circuit on its own. &lt;br /&gt;
At this point we were satisfied with the circuit’s performance using a crystal earphone and piezoelectric speaker. However, both of these audio devices are not easily obtainable, so we further worked on developing other circuits that can connect to commercially available audio devices.
Below is a transistor amplification circuit for low impedance ear phones.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-F5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fig 2.F.5 - Low Impedance Earphone Amplifier&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Below is a speaker amplifier made using an LM358 audio amplifier. We followed the recommended circuit designed for 200dB gain by the manufacturer and had great results. The only downside is that the speaker draws too much current and will most definitely be a viable option in emergencies.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-11-12-F6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fig 2.F.6 - Low Impedance Speaker Amplifier&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Excerpt from final design report for fulfillment of requirements for ELEC 391, June 2016-11&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Part 1 can be found at: &lt;a href=&quot;http://c4coffee.ca/2016/10/30/diy-am-radio.html&quot;&gt;http://c4coffee.ca/2016/10/30/diy-am-radio.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 12 Nov 2016 00:00:00 -0800</pubDate>
        <link>http://localhost:4000/2016/11/12/diy-am-radio-part2.html</link>
        <guid isPermaLink="true">http://localhost:4000/2016/11/12/diy-am-radio-part2.html</guid>
        
        
      </item>
    
      <item>
        <title>DIY AM Radio Design - Part1: Background</title>
        <description>&lt;p&gt;As part of a project course over the summer, we were tasked to build a self-powered AM radio with easy assembly. The motivations were as follows:
&lt;ul&gt;
  &lt;li&gt;Easy assembly allows good education material for younger children&lt;/li&gt;
  &lt;li&gt;Self-powering allows for use during emergency situations&lt;/li&gt;
  &lt;li&gt;There is good AM radio coverage in the Vancouver area&lt;/li&gt;
  &lt;li&gt;FM radios are slightly more complicated than AM radio&lt;/li&gt;
&lt;/ul&gt;

Below are sections extracted from our team's final report.&lt;/p&gt;

&lt;h2 id=&quot;construction-background&quot;&gt;Construction Background&lt;/h2&gt;

&lt;p&gt;Shown below is a block diagram of what we recognized as the major components required for the construction of an AM radio.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-10-30.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;b&gt;RF(Radio Frequency) receiver&lt;/b&gt; is an electrical component that captures electromagnetic waves in the radio frequency range and converts it to electrical power. &lt;br /&gt;
Our &lt;b&gt;RF selection mechanism&lt;/b&gt; is essentially a frequency filter that will allow us to choose the frequency at which we are listening to. It is important to note that in most cases, the RF receiver does not exclusively receive one single channel, therefore a filter is required to filter out other channels we do not want. &lt;br /&gt;
The next important step is to amplify the RF signal received. But from research it was realized quickly that RF amplification was not an easy task, and that for the applications of our project it was unnecessary.  &lt;br /&gt;
Since there was no RF Amplification, &lt;b&gt;AF(Audio Frequency) Amplification&lt;/b&gt; was necessary after &lt;b&gt;Demodulation&lt;/b&gt; where the carrier signal was separated from our modulated signal.&lt;/p&gt;

&lt;h2 id=&quot;signal-processing-background&quot;&gt;Signal Processing Background&lt;/h2&gt;

&lt;p&gt;The most important concept to learn for this project was the theory behind modulation. In the simplest terms, AM modulation simply meant that we have a very fast oscillating &lt;b&gt;carrier signal&lt;/b&gt; that was representing itself as our &lt;b&gt;information signal&lt;/b&gt;, which are the audio signals from the radio stations in our case.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;display: flex; justify-content: center;&quot; src=&quot;https://upload.wikimedia.org/wikipedia/commons/a/a4/Amfm3-en-de.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To understand &lt;b&gt;demodulation&lt;/b&gt; it would be important to understand how to interpret the signals. Sine signals can be represented by two peaks at +/- of their frequencies. Like below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blogs.mathworks.com/images/steve/2009/F_cos_t.png&quot; alt=&quot;mathworks&quot; /&gt;&lt;/p&gt;

&lt;p&gt;With the combination of our modulated signal and our carrier signal, we will get something that looks more like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/a/ae/AM_spectrum.svg/600px-AM_spectrum.svg.png&quot; alt=&quot;wikipedia&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Where the signal above is the signal we are modulating, and the signals below is our same signal after modulation. It can be observed that the original signal centered is now separated into two signals at higher frequencies. This is because, our original signal is now being represented by a signal that oscillates at higher frequencies.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Image sources:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/File:Amfm3-en-de.gif&quot;&gt;Wikepedia: Amplitude Modulation GIF&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blogs.mathworks.com/steve/2010/05/27/negative-frequencies/&quot;&gt;Mathworks Blogs: Steve Eddins on Negative Frequencies&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/File:AM_spectrum.svg&quot;&gt;Wikipedia: Amplitude Modulation AM Spectrum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;Part 2 can be found at: &lt;a href=&quot;http://c4coffee.ca/2016/11/12/diy-am-radio-part2.html&quot;&gt;http://c4coffee.ca/2016/11/12/diy-am-radio-part2.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 30 Oct 2016 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/2016/10/30/diy-am-radio.html</link>
        <guid isPermaLink="true">http://localhost:4000/2016/10/30/diy-am-radio.html</guid>
        
        
      </item>
    
      <item>
        <title>Understanding ROS</title>
        <description>&lt;p&gt; Recently I've been reached out via email, A2A about the function of ROS. For people who are new to ROS, it is hard to grasp what ROS is and why we need it. Below is a copy of the question, link to the question, and my answer. &lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;~~~&lt;/p&gt;

&lt;h1 id=&quot;question-what-is-the-role-of-ros-in-a-complete-robothttpanswersrosorgquestion237411what-is-the-role-of-ros-in-a-complete-robot237420&quot;&gt;&lt;a href=&quot;http://answers.ros.org/question/237411/what-is-the-role-of-ros-in-a-complete-robot/#237420&quot;&gt;Question: What is the role of ROS in a complete robot?&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;After raising this question, I’ve realized that, unlike what I’ve known as an iOS developer that iOS is almost the only thing we developers should concern, ROS itself is not an operating system but a framework, a set of libraries. And besides that, what a robot exposes to developers are far more than an iPhone does. So these are all new concepts for me to absorb and it may take a while ;)&lt;/p&gt;

&lt;p&gt;My question is, what’s the role of ROS in a robot?&lt;/p&gt;

&lt;p&gt;Can someone please give us a detailed explanation of what a robot is generally comprised of, with examples? Say in Roomba, I know it has its own operating system; what part of Roomba plays a similar role as ROS?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;snakeninny&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;~~~&lt;/p&gt;

&lt;p&gt;Hello snakeninny,&lt;/p&gt;

&lt;p&gt;At this point in your research I hope you now understand the concept of nodes and packages in ROS, or simply the existence of them. Due to the complexity of a lot of the decisions made or computations being performed by the robot, it is no longer feasible for all of the software to be written in one package. Therefore a lot of functionalities are grouped into these nodes and executed together.&lt;/p&gt;

&lt;p&gt;From your background, you can understand these nodes as objects that does different things. Eg. A node that processes computer vision; an eye object. A node that processes speech; an mouth object. A node that processes actuator controls, a cerebellum object. Objects in a OOD sense.&lt;/p&gt;

&lt;p&gt;What ROS as an “operating system” does is to facilitate a framework where these nodes can all communicate with one another to perform complex tasks that requires simultaneous stimuli from different sensors and perform calculations.&lt;/p&gt;

&lt;p&gt;The Roomba is a very simple robot compared to other systems you may see being created with ROS. A Roomba replica can easily be created with an Arduino. It’s like comparing a goldfish to a human brain. We can no doubt sleep, eat and move as a goldfish can; just like how a ROS system can do what a Roomba does. But in cases where you want to be able to tell the difference between what you are eating, or being able to dance, a goldfish cannot do that.&lt;/p&gt;

&lt;p&gt;In most cases, I like to think of micro controllers like the arduino as controllers for individual components, taking orders from individual nodes. Eg. A movement node says it wants to move forward, and the arduino controls the ESC on the robot to move the motor. The arduino knows how to turn, how to activate motors, but it will not be smart enough to know how to move to properly tango.&lt;/p&gt;

&lt;p&gt;A usual chain of command in systems I work with looks something like:&lt;/p&gt;

&lt;p&gt;Sensors detect object
AI node uses other sensors to decide what type of object it is
AI decides that it needs to move left-forward-right to avoid the object
Movement node receives left-forward-right command from AI
Movement node sends left, forward, right as seperate commands to the Arduino that controlls the motors, checking between commands that the robot is moving correctly.
All this is based off of my own understanding and experience with ROS, and ROS can certainly be more complex or simple depending on the application. But hopefully this is a starting point for you.&lt;/p&gt;

&lt;p&gt;Cheers, Dulluhan&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;~~~&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Jun 2016 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/2016/06/14/Understanding-ROS.html</link>
        <guid isPermaLink="true">http://localhost:4000/2016/06/14/Understanding-ROS.html</guid>
        
        
      </item>
    
      <item>
        <title>Arduino Serial Communication Problem and Fix</title>
        <description>&lt;p&gt;Since the primary work I do is interfacing ROS with microcontrollers for sensor/actuator controls, I would like to share a problem that you may often encounter when doing any time of data transmission.&lt;/p&gt;

&lt;p&gt;Of course there may be more elegant ways of solving this issues if these are even issues. But from what I observed before and after the fixes, my hypothesis for the problems seemed to be solved.&lt;/p&gt;

&lt;h1 id=&quot;buffer-flushing-for-arduinos&quot;&gt;Buffer Flushing for arduinos&lt;/h1&gt;
&lt;p&gt;Problem: When ROS loops are running at a frequency much higher than the arduino can process incoming commands, you may get problems with data in your buffer either holding too much, or not being processed correctly.&lt;/p&gt;

&lt;p&gt;Situation: Our method of actuator resolves around sending custom &lt;a href=&quot;http://docs.ros.org/api/geometry_msgs/html/msg/Twist.html&quot;&gt;twist messages&lt;/a&gt; that have the format of: (Lx, Ly, Az). Where Lx/Ly is linear x,y and Az is angular z. What they give us are the motion commands of moving forwards, sideways and turning.&lt;/p&gt;

&lt;p&gt;When the robot is hooked up to our laptop via USB, we are constantly bombarding the arduino serial port with multiple twist messages a second. I have observed that under certain circumstances, the arduino will either process messages with slight delay to the computed twist messages, or it will competely “hang” and freeze the serial port.&lt;/p&gt;

&lt;p&gt;Of course the first solution I thought of was to flush the buffer via &lt;code class=&quot;highlighter-rouge&quot;&gt;Serial.flush();&lt;/code&gt; for the arduino to always process the newest data. However, what I did not know was that the arduino’s flush function under the HardwareSerial.h library was flushing the output buffer not the input buffer, therefore I had to dig around on the internet to see what &lt;a href=&quot;https://forum.sparkfun.com/viewtopic.php?f=32&amp;amp;t=32715&quot;&gt;others have done to fix this problem.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Solution: Adding a function to the HarwareSerial.cpp file in the Arduino library files.&lt;/p&gt;

&lt;p&gt;For the .h, add a new function declaration &lt;code class=&quot;highlighter-rouge&quot;&gt;virtual void flushRX();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For the .cpp, add the rest of the function:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HardwareSerial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flushRX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;_rx_buffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_rx_buffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

</description>
        <pubDate>Sun, 27 Mar 2016 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/2016/03/27/Arduino-Serial-Communication-Fix.html</link>
        <guid isPermaLink="true">http://localhost:4000/2016/03/27/Arduino-Serial-Communication-Fix.html</guid>
        
        
      </item>
    
      <item>
        <title>Setting Up ChromeOS for ROS</title>
        <description>&lt;p&gt;This post will be focused on listing the preliminary setup requied to facilitate ROS on Chromebooks. The Chromebook that I will be using through this post will be a c720 (2gb/2995U).&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;~~~&lt;/p&gt;

&lt;p&gt;To start it is important to discuss the different options that are offered to Chromebooks for running Linux. If your are just getting into the Chromebook lineup, you probably have heard about Chrubuntu and Crouton. Here are my 2cents on the differnce:&lt;/p&gt;

&lt;h1 id=&quot;chrubuntuhttpswwwredditcomrchrubuntucomments1rsxkdlistoffixesforxubuntu1310ontheacerc720&quot;&gt;&lt;a href=&quot;https://www.reddit.com/r/chrubuntu/comments/1rsxkd/list_of_fixes_for_xubuntu_1310_on_the_acer_c720&quot;&gt;Chrubuntu&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt; Chrubuntu is essentially a hack to bring any Linux distro of your choice in replacement of ChromeOS that comes with your chromebook. I have used this for the longest time in the past and it has caused me more problems than not. Particularily hardware compatibiltiy is the primary concern. From fixing the trackpad to optimizing chrome on a clean linux install, its just not worth the effort in my personal opinion. 
&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;croutonhttpsgithubcomdnschneidcrouton&quot;&gt;&lt;a href=&quot;https://github.com/dnschneid/crouton&quot;&gt;Crouton&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Crouton stands for ChRomium Os Universal chrooT envirONment. Understanding crouton from the surface is that you are essentially running ChromeOS parallel to a distro of your choice. I resorted to Crouton again after a whole year of Chrubuntu simply because I was sick of dealing with the trackpad and processor problems after os updates with Chrubuntu.     
&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;~~~&lt;/p&gt;

&lt;p&gt;In the end of the day I picked crouton, and what I am left with all the benefits of optimized software from Chromebook and the power of a fully functional linux distro. Besides, having a chromeOS operating a robot is hilarious.&lt;/p&gt;

&lt;p&gt;Now to discuss somethings that will make your ROS setup and usage smooth:&lt;/p&gt;

&lt;h1 id=&quot;xiwihttpsgithubcomdnschneidcroutonwikicrouton-in-a-chromium-os-window-xiwi&quot;&gt;&lt;a href=&quot;https://github.com/dnschneid/crouton/wiki/crouton-in-a-Chromium-OS-window-(xiwi)&quot;&gt;xiwi&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;Xiwi is just X11 in a window. Rather than having to switch between workspaces using the ctrl+shift+alt+F1 “shortcut”, you can just have your chroot (crouton instance) running in a window. The whole concept is just -x forwarding your workplace to the chromOS bash shell.&lt;/p&gt;

&lt;p&gt;To install xiwi you can include the installation of it at the initial setup of your chroot.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo sh ~/Downloads/crouton -t xiwi,xfce&lt;/code&gt;&lt;br /&gt;
In the case where you decide to use xubuntu as your chroot distro.&lt;/p&gt;

&lt;p&gt;Alternatively you can upgrade your current chroot. For example, if I was using ubuntu precise, I can update it via: 
&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo sh ~/Downloads/crouton -n precise -u -t xiwi&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;After installation, if you would like to run instances of your chroot you can just -x forward it to xiwi: 
&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo distro -X xiwi&lt;/code&gt;  eg. $ sudo startxfce4 -X xiwi&lt;/p&gt;

&lt;p&gt;If you just want to run the CLI, you can run: 
&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo enter-chroot&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo enter-chroot -n chroot_name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You can even run specific programs like so: 
&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo enter-chroot&lt;/code&gt; followed by &lt;code class=&quot;highlighter-rouge&quot;&gt;$ xiwi -T arduino&lt;/code&gt;(tab) or &lt;code class=&quot;highlighter-rouge&quot;&gt;$ xiwi -F arduino&lt;/code&gt;(window) after you enter your chroot. Further, by adding &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; to indicate that you want to run the program with the terminal prompt still being available. 
Forwarded programs can be killed via &lt;code class=&quot;highlighter-rouge&quot;&gt;$ kill&lt;/code&gt; or simply closing the window/tab.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;ros-installation-notes&quot;&gt;ROS Installation Notes&lt;/h1&gt;

&lt;p&gt;One of the only crippling problem that took me a bit to fix was that ROS could would not install on xfce that I had setup on my initial install of crouton. After some research I realized that the version of xubuntu I was running was not supported. It is important to note that I am setting up ROS-indigo for compatibility with my teams’ code&lt;/p&gt;

&lt;p&gt;After reading the &lt;a href=&quot;http://wiki.ros.org/indigo/Installation/Ubuntu&quot;&gt;ROS-indgo’s installation page&lt;/a&gt; I realized that Precise was no longer supported. I therefore had to do an &lt;a href=&quot;https://github.com/dnschneid/crouton/wiki/Upgrade-chroot-release&quot;&gt;OS update to Trusty&lt;/a&gt;. After that a simple installation &lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo apt-get install ros-indigo-desktop-full&lt;/code&gt; was able to set me up.&lt;/p&gt;

&lt;p&gt;Don’t forget to &lt;code class=&quot;highlighter-rouge&quot;&gt;$ source /opt/ros/indigo/setup.bash&lt;/code&gt; or echo it into your .bashrc as I scratched my head over &lt;code class=&quot;highlighter-rouge&quot;&gt;$ roscore&lt;/code&gt; giving me &lt;code class=&quot;highlighter-rouge&quot;&gt;command not found&lt;/code&gt; for the longest time.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;other-software&quot;&gt;Other Software&lt;/h1&gt;

&lt;p&gt;Originally the thing I was most concerned with was my control over serial or networking ports. As my job surrounds alot around testing firmware 
via USB, I was worried that chromebooks would have some security feature that would lock it up to prevent me from accessing them. But lo and behold:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/8agwotmdphbw1eq/Screenshot%202016-03-24%20at%2011.11.53%20PM.png?raw=1&quot; class=&quot;img-thumbnail&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Also to verify, the permissions carry over in chroot:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/7q1h4ccf8m6zhrs/Screenshot%202016-03-24%20at%2011.14.57%20PM.png?raw=1&quot; class=&quot;img-thumbnail&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Then I also tested program’s abilities to access these ports. Eg. Arduino. A easy blinky test on an uno showed that everything seems to be setup for development. Installing arduino in the chroot, I ran &lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo xiwi -F arduino&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/0h1y9ainpfhxeuh/Screenshot%202016-03-25%20at%2012.07.50%20AM.png?raw=1&quot; class=&quot;img-thumbnail&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 24 Mar 2016 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/ros/2016/03/24/Setting-Up-ChromeOS-For-ROS.html</link>
        <guid isPermaLink="true">http://localhost:4000/ros/2016/03/24/Setting-Up-ChromeOS-For-ROS.html</guid>
        
        
        <category>ROS</category>
        
      </item>
    
      <item>
        <title>ChromeOS as a Robotics Platform</title>
        <description>&lt;p&gt;After purging my old setup for the blog since it was empty and gross, I decide to start the fresh blog with an useful post. After 9 hours of testing and tweaking I finally removed chrubuntu from my c720 and installed crouton with xfce::ubuntu14.04 (Which is very important as ROS-indigo does not support 10.2 which is default with crouton)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/kqe8xq0li0e227x/Screenshot%202016-03-23%20at%2011.35.12%20PM.png?raw=1&quot; class=&quot;img-thumbnail&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The beauty of this setup however lies in the fact that I can run a suite of tools that are essential for my job on the team to produce software and firmware. This includes being able to build our system under Robotics Operating System(ROS) and arduino code for the firmware side.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/0cl6i39zlq3z8yo/Screenshot%202016-03-23%20at%2011.57.23%20PM.png?raw=1&quot; class=&quot;img-thumbnail&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It is midnight so ideally, in the next few days I can put up a few more posts regarding not only setting up ROS on chromeOS but also some jekyll tutorials since there were certain things that took me a while to learn. As I start writing more posts I will also be able to add some more setup screen shots once my c100 gets here for me to abuse.&lt;/p&gt;

</description>
        <pubDate>Wed, 23 Mar 2016 23:18:42 -0700</pubDate>
        <link>http://localhost:4000/ros/2016/03/23/chromeOS-as-a-robotics-platform.html</link>
        <guid isPermaLink="true">http://localhost:4000/ros/2016/03/23/chromeOS-as-a-robotics-platform.html</guid>
        
        
        <category>ROS</category>
        
      </item>
    
  </channel>
</rss>
